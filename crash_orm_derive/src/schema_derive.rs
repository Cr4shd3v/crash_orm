use proc_macro::TokenStream;

use crate::reserved_keywords::escape_reserved_keywords;
use crate::util::{get_attribute_by_name, get_type_string, ident_to_table_name, rust_to_postgres_type};
use quote::quote;
use syn::{parse_macro_input, Data, DeriveInput};

pub fn derive_schema_impl(input: TokenStream) -> TokenStream {
    let derive_input = parse_macro_input!(input as DeriveInput);
    let Data::Struct(struct_data) = derive_input.data else {
        panic!("only structs are supported")
    };

    let mut create_fields_string = String::new();

    let ident = derive_input.ident;
    let ident_str = ident_to_table_name(&ident);
    let mut id_is_uuid = false;

    let primary_field_name = {
        let mut defined_primary_key = None;
        let mut defined_primary_key_name = None;

        for field in &struct_data.fields {
            let field_ident = field.ident.as_ref().unwrap();
            let field_ident_str = field_ident.to_string();

            let primary_key = get_attribute_by_name(field, "primary_key").is_some();
            if primary_key {
                defined_primary_key = Some(field.ty.clone());
                defined_primary_key_name = Some(field_ident_str);
            }
        }

        if defined_primary_key.is_some() {
            defined_primary_key_name.unwrap()
        } else {
            "id".to_string()
        }
    };

    for field in struct_data.fields {
        let field_name = field.ident.clone().unwrap().to_string();
        let column_type = rust_to_postgres_type(&field.ty, &*field_name);

        if column_type.is_none() {
            continue;
        }
        let column_type = column_type.unwrap();

        create_fields_string.push_str(&*format!("{} {}", escape_reserved_keywords(&field_name), column_type));

        if &*field_name == primary_field_name {
            let field_type_str = get_type_string(&field.ty);

            if field_type_str == "Option" {
                panic!("The primary key must not be an Option!");
            }

            // Uuid should not be generated by the database
            if field_type_str != "Uuid" {
                create_fields_string.push_str(&*format!(
                    " DEFAULT nextval('{}_{}_seq'::regclass)",
                    ident_str, primary_field_name,
                ));
            } else {
                id_is_uuid = true;
            }
        }

        create_fields_string.push_str(",");
    }

    create_fields_string.push_str(&*format!("PRIMARY KEY ({})", primary_field_name));

    let create_string = format!(
        "CREATE TABLE public.{}({});",
        ident_str, create_fields_string
    );

    let sequence_create_quote = if !id_is_uuid {
        let sequence_create = format!("CREATE SEQUENCE {}_{}_seq", ident_str, primary_field_name);
        quote! {
            connection.execute_query(#sequence_create, &[]).await?;
        }
    } else {
        quote!()
    };
    let sequence_created_alter_quote = if !id_is_uuid {
        let sequence_created_alter = format!("ALTER SEQUENCE {0}_{1}_seq OWNED BY \"{0}\".{1}", ident_str, primary_field_name);
        quote! {
            connection.execute_query(#sequence_created_alter, &[]).await?;
        }
    } else {
        quote!()
    };

    let drop_string = format!("DROP TABLE IF EXISTS {} CASCADE", ident_str);
    let truncate_string = format!("TRUNCATE {} RESTART IDENTITY CASCADE", ident_str);
    let table_exists_string = format!(
        "SELECT EXISTS(SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = '{}')",
        ident_str
    );

    let output = quote! {
        #[crash_orm::async_trait::async_trait]
        impl crash_orm::prelude::Schema for #ident {
            async fn create_table(connection: &impl crash_orm::prelude::DatabaseConnection) -> crash_orm::Result<()> {
                #sequence_create_quote
                connection.execute_query(#create_string, &[]).await?;
                #sequence_created_alter_quote

                Ok(())
            }

            async fn drop_table(connection: &impl crash_orm::prelude::DatabaseConnection) -> crash_orm::Result<()> {
                connection.execute_query(#drop_string, &[]).await?;

                Ok(())
            }

            async fn truncate_table(connection: &impl crash_orm::prelude::DatabaseConnection) -> crash_orm::Result<()> {
                connection.execute_query(#truncate_string, &[]).await?;

                Ok(())
            }

            async fn table_exists(connection: &impl crash_orm::prelude::DatabaseConnection) -> crash_orm::Result<bool> {
                let row = connection.query_single(#table_exists_string, &[]).await?;
                let exists: bool = row.get(0);
                Ok(exists)
            }
        }
    };

    output.into()
}
